{"boxworldShader":{"mainProgram":{"code":{"fragmentCode":{"frag":"#version 330\nlayout(location = 0) out vec4 glFragColor;\nin vec4 glFragCoord; // custom version of gl_FragCoord, used for tiled rendering.\n#define SYNTHCLIPSE_ONLY\n/*!\n * <info>\n * <author>nimitz [ https://www.shadertoy.com/user/nimitz ]<\/author>\n * <name>Satellite's eye<\/name>\n * \n * <description>\n *   Mouse up/down to change water level.<br/>Mouse left/right to change influence\n *   of derivatives (left = less influence)\n * <\/description>\n * \n * <url>https://www.shadertoy.com/view/4tX3Ws<\/url>\n * \n * <date>2015-06-20<\/date>\n * \n * <tags>terrain, map, relief<\/tags>\n * \n * <synthclipse-importer-legal-note>\n *   As noted in: [ https://www.shadertoy.com/terms ]:\n *   If the author did not stated otherwise, this shader is licensed under\n *   Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License \n *   [ http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US ].\n * <\/synthclipse-importer-legal-note>\n * <\/info>\n */\n\nuniform vec3      iResolution;           // viewport resolution (in pixels)\nuniform float     iGlobalTime;           // shader playback time (in seconds)\nuniform float     iTimeDelta;            // render time (in seconds)\nuniform int       iFrame;                // shader playback frame\nuniform float     iChannelTime[4];       // channel playback time (in seconds)\nuniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\nuniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\nuniform vec4      iDate;                 // (year, month, day, time in seconds)\nuniform float     iSampleRate;           // sound sample rate (i.e., 44100)\nuniform sampler2D iChannel0; //! texture[\"Shadertoy/res/tex16.png\"]\n\nuniform sampler2D depthTex;\t\t\t //! depthmap[]\n\n//Satellite's eye by nimitz (twitter: @stormoid)\n\n/*\nVery few shaders on shadertoy use iq's great anylitic noise derivative technique \n(http://www.iquilezles.org/www/articles/morenoise/morenoise.htm)\n\nThe main goal was to get torrain that looks good enough on the \"continental\" scale\n*/\n\n#define time iGlobalTime\n\n//#define CLOUDS\n\nvec2 mo = vec2(0);\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\n\n//for clouds\nfloat fbm( in vec2 p )\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i<5.;i++ )\n\t{\n        rz+= (sin(noise(p)*5.)*.5+0.5)/z;\n\t\tz = z*2.3;\n        p*= m2;\n\t\tp = p*2.3;\n\t}\n\treturn rz;\n}\n\n\n//http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    //vec2 u = f*f*f*(f*(f*6. - 15.) + 10.); //Quintic smoothsing\n\tfloat a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain(in vec2 p)\n{/*\n    float a = 0.0;\n    float z = 1.;\n    vec2 bp = p;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz*mo.x;\n        a += z * n.x/(dot(d,d)+1.);\n        \n\t\tz *= .49;\n        p = m2*p*2.17;\n    }\n    \n    a += mo.y*0.5-0.15;\n    \n    a *= exp(a*1.5-2.5);\n    a = smoothstep(-0.5,.3,a)*.15 + (smoothstep(.3,.5,a)*.5) + smoothstep(.65,3.,a)*5. - smoothstep(.9,-.35,a)*.25;\n*/\n\tfloat depth = texture(depthTex, p).r;\n    return depth;\n}\n\n\nvec3 normal(in vec2 p, in float h, in float w)\n{\n    vec2 e = vec2(w,0.);\n    return normalize( vec3( terrain(p+e.xy) - terrain(p-e.xy), h, terrain( p+e.yx)-terrain(p-e.yx) ) );\n}\n\nvec3 tex(in vec2 p)\n{\n    vec3 col = vec3(1);\n    \n    float rz = terrain(p);\n    vec2 dd = vec2(.707);\n    \n    //coastal smoothing\n    float coast = smoothstep(0.,.2, rz)-smoothstep(0.2,.65, rz);\n    \n    float dif = clamp(dot( normal(p, 0.019+coast*0.05, 0.008-coast*0.004),(vec3(dd.x,0.1,dd.y)) )*0.5+0.5,0.0,1.);\n    float dif2 = clamp(dot( normal(p, .9, .25),(vec3(dd.x,.7,dd.y)) )*0.5+0.5,0.0,1.);\n    \n    float fbm1 = fbm(p*0.75);\n    float nz = texture(iChannel0,p*iResolution.xy*0.0015).r*0.4+0.5;\n    \n    float wtr = smoothstep(-1.,.1, rz)-smoothstep(-.05,.2, rz);\n    col -= wtr*vec3(1.,0.85,.7)*1.1 + smoothstep(0.3,.7,fbm1)*0.1*wtr;\n    \n    \n    float grass = smoothstep(0.2,.6, rz)-smoothstep(0.6,.7, rz);\n    col -= (smoothstep(-1.,0.,rz)*(nz*0.5+0.5))*grass;\n    col += col*grass*vec3(0.25,0.5,0.05)*1.5;\n    \n    col -= coast*(nz*.4)*vec3(.7,.75,1.1);\n    \n    float mount = smoothstep(0.52,.7, rz);\n    col -= col*mount*vec3(.5,.75,1.)*(fbm(p*3.)-0.1)*0.45;\n    \n    col *= dif*dif2;\n    \n    #ifdef CLOUDS\n    const float scl = .55;\n    float clo2 = fbm(p*scl);\n    vec2 e = vec2(0.07+fbm(p*2.)*0.6,0.);\n    vec3 cldn = normalize( vec3( fbm((p+e.xy)*scl) - clo2, .3, fbm( (p+e.yx)*scl) - clo2 ) );\n    float cldif = max(dot(cldn,(vec3(dd.x,0.4,dd.y))),0.);\n    clo2 = smoothstep(.0,1.,cldif * ((cldif-clo2)*1.+0.));\n    col = mix(col, vec3(1.), clo2);\n    #endif\n    \n    col = clamp(col,0.,1.);\n    col = pow(col,vec3(.75));\n    \n    return col;\n}\n\nfloat sphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    \n    if(h <0.0) return -1.;\n    else return -b + sqrt(h);\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvoid mainImage( inout vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.y;\n\tp.x /= iResolution.x/iResolution.y;\n\tmo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.0,-0.05):mo;\n    mo.x = mo.x*0.75+0.5;\n    mo.y += mo.x*0.5;\n    \n    //vec3 ro = vec3(0, 0, 0);\n    //vec3 rd = normalize(vec3(p, 1.0));\n\n    \tvec3 right = vec3(1, 0, 0);\n    \tvec3 front = vec3(0, 0, 1);\n    \tvec3 ro = right * p.x + front * p.y;\n    \tro.y += 1.0;\n    \tvec3 rd = normalize(cross(right, front));\n\n    float t = sphere(ro,rd);\n    \n    vec3 col = vec3(0);\n    //if (t > 0.)\n    {\n        vec3 pos = ro + rd*t;\n        //pos.xy /= pos.z;\n        //pos.y -= time*0.025;\n        col = tex(pos.xz);\n        \n    }\n\t\n\tfragColor = vec4(col,1.0);\n}\n\nvoid main() {\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\tmainImage(color, glFragCoord.xy);\n\n\tglFragColor = color;\n}\n\n\n","fragUniformControlList":[{"name":"iChannel0","typeString":"sampler2D","value":"Shadertoy/res/tex16.png"},{"name":"depthTex","typeString":"sampler2D","value":"[depthmap]"}]},"vertexCode":{"vert":"#version 330\n#define SYNTHCLIPSE_ONLY\nlayout(location = 0) in vec3 VertexPosition;\n\n// Matrix used for tiled rendering:\nuniform mat4 TileMatrix = mat4(1.0);\nuniform vec2 resolution;\n\n// custom version of gl_FragCoord, used for tiled rendering.\nout vec4 glFragCoord;\n\nvoid main() {\n\tvec2 v = VertexPosition.xy;\n\tv.x = v.x * TileMatrix[0][0] + TileMatrix[3][0];\n\tv.y = v.y * TileMatrix[1][1] + TileMatrix[3][1];\n\tv = v * 0.5 + 0.5;\n\tglFragCoord.xy = v * resolution;\n\n\tgl_Position = vec4(VertexPosition, 1.0);\n}\n\n\n"}},"name":"Satellite's-eye.stoy"}}}
