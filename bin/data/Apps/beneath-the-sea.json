{"boxworldShader":{"mainProgram":{"code":{"fragmentCode":{"frag":"#version 330\nlayout(location = 0) out vec4 glFragColor;\nin vec4 glFragCoord; // custom version of gl_FragCoord, used for tiled rendering.\n#define SYNTHCLIPSE_ONLY\n/*!\n * <info>\n * <author>zel [ https://www.shadertoy.com/user/zel ]<\/author>\n * <name>Beneath the Sea<\/name>\n * \n * <description>\n *   Sprites float in their underwater home.\n * <\/description>\n * \n * <url>https://www.shadertoy.com/view/4ljXWh<\/url>\n * \n * <date>2015-09-27<\/date>\n * \n * <tags>ray, terrain, rays, water, circle, marching, caustic, god<\/tags>\n * \n * <synthclipse-importer-legal-note>\n *   As noted in: [ https://www.shadertoy.com/terms ]:\n *   If the author did not stated otherwise, this shader is licensed under\n *   Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License \n *   [ http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US ].\n * <\/synthclipse-importer-legal-note>\n * <\/info>\n */\n\nuniform vec3      iResolution;           // viewport resolution (in pixels)\nuniform float     iGlobalTime;           // shader playback time (in seconds)\nuniform float     iChannelTime[4];       // channel playback time (in seconds)\nuniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\nuniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\nuniform vec4      iDate;                 // (year, month, day, time in seconds)\nuniform float     iSampleRate;           // sound sample rate (i.e., 44100)\nuniform sampler2D iChannel1; //! texture[\"Shadertoy/res/tex03.jpg\"]\nuniform sampler2D iChannel2; //! texture[\"Shadertoy/res/tex03.jpg\"]\nuniform sampler2D iChannel0; //! texture[\"Shadertoy/res/tex16.png\"]\nuniform float z_pos;\t\t\t\t//! slider[-2, -1.182, 2];\nuniform sampler2D depthTex;\t\t//! depthmap[]\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// partially derived from the following\n// https://www.shadertoy.com/view/MlB3zh - terrain base\n// https://www.shadertoy.com/view/MdlXz8 - caustic tile\n\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\n\nfloat speck(vec2 pos, vec2 uv, float radius)\n{\n    pos.y += 0.05;\n    float color = distance(pos, uv);\n    vec3 tex = texture(iChannel0, sin(vec2(uv)*10.1)).xyz;\n    vec3 tex2 = texture(iChannel0, sin(vec2(pos)*10.1)).xyz;\n    color = clamp((1.0 - pow(color * (5.0 / radius), pow(radius,0.9))), 0.0, 1.0);\n    color *= clamp(mix(sin(tex.y)+0.1,cos(tex.x),0.5)*sin(tex2.x)+0.2,0.0,1.0);\n    return color;\n}\n\n\nvec3 caustic(vec2 uv)\n{\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n    float time = iGlobalTime * .5+23.0;\n\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 color = vec3(pow(abs(c), 8.0));\n    color = clamp(color + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    color = mix(color, vec3(1.0,1.0,1.0),0.3);\n    \n    return color;\n}\n\n\n// perf increase for god ray, eliminates Y\nfloat causticX(float x, float power, float gtime)\n{\n    float p = mod(x*TAU, TAU)-250.0;\n    float time = gtime * .5+23.0;\n\n\tfloat i = p;;\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER/2; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + cos(t - i) + sin(t + i);\n\t\tc += 1.0/length(p / (sin(i+t)/inten));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, power);\n    \n    return c;\n}\n\n\nfloat GodRays(vec2 uv)\n{\n    float light = 0.0;\n\n    light += pow(causticX((uv.x+0.08*uv.y)/1.7+0.5, 1.8, iGlobalTime*0.65),10.0)*0.05;\n    light-=pow((1.0-uv.y)*0.3,2.0)*0.2;\n    light += pow(causticX(sin(uv.x), 0.3,iGlobalTime*0.7),9.0)*0.4; \n    light += pow(causticX(cos(uv.x*2.3), 0.3,iGlobalTime*1.3),4.0)*0.1;  \n        \n    light-=pow((1.0-uv.y)*0.3,3.0);\n    light=clamp(light,0.0,1.0);\n    \n    return light;\n}\n\n\nfloat noise(in vec2 p)\n{\n   \n    float height = mix(texture(iChannel0, p / 80.0, -100.0).x,1.0,0.85);\n    float height2 = mix(texture(iChannel1, p / 700.0, -200.0).x,0.0,-3.5);\n    \n    return height2-height-0.179;\n}\n\n\nfloat fBm(in vec2 p) \n{\n\tp += 1.0;\n\tp /= 2.0;\n\treturn texture(depthTex, p).r * 0.16;\n}\n\n\nvec3 raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n    float t = tmin;\n    vec3 res = vec3(-1.0);\n    \n    for (int i = 0; i < 110; i++) \n    {\n        vec3 p = ro + rd * t;\n        \n        res = vec3(vec2(0.0, p.y - fBm(p.xz)), t);\n        \n        float d = res.y;\n        \n        if (d < (0.001 * t) || t > tmax)\n        {\n            break;\n        }\n        \n        t += 0.5 * d;\n    }\n    \n    return res;\n}\n\n\nvec3 getTerrainNormal(in vec3 p) \n{\n    float eps = 0.025;\n    return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 skyColor = vec3(0.3, 1.0, 1.0);\n\n    vec3 sunLightColor = vec3(1.7, 0.65, 0.65);\n    vec3 skyLightColor = vec3(0.8, 0.35, 0.15);\n    vec3 indLightColor = vec3(0.4, 0.3, 0.2);\n    vec3 horizonColor = vec3(0.0, 0.05, 0.2);\n    vec3 sunDirection = normalize(vec3(0.8, 0.8, 0.6));\n    \n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.91, z_pos);\n    vec3 cameraTarget = vec3(p.x, 0.0, p.y);\n    vec3 cameraDir = normalize(cameraTarget - ro);\n    vec3 rd = cameraDir;\n\n    // background\n    vec3 color = skyColor;\n    float sky = 0.0;\n\n    // terrain marching\n    float tmin = 0.1;\n    float tmax = 20.0;\n    vec3 res = raymarchTerrain(ro, rd, tmin, tmax);\n    \n    vec3 colorBubble = vec3(0.0);\n    float bubble = 0.0;\n    bubble +=  speck(vec2(sin(iGlobalTime*0.32),cos(iGlobalTime)*0.2+0.1),rd.xy,-0.08*rd.z);\n\tbubble +=  speck(vec2(sin(1.0-iGlobalTime*0.39)+0.5,cos(1.0-iGlobalTime*0.69)*0.2+0.15),rd.xy,0.07*rd.z);   \n\tbubble +=  speck(vec2(cos(1.0-iGlobalTime*0.5)-0.5,sin(1.0-iGlobalTime*0.36)*0.2+0.1),rd.xy,0.12*rd.z);   \n \tbubble +=  speck(vec2(sin(iGlobalTime*0.44)-1.0,cos(1.0-iGlobalTime*0.32)*0.2+0.15),rd.xy,-0.09*rd.z);   \n \tbubble +=  speck(vec2(1.0-sin(1.0-iGlobalTime*0.6)-1.3,sin(1.0-iGlobalTime*0.82)*0.2+0.1),rd.xy,0.15*rd.z);\n\n    colorBubble = bubble*vec3(0.2,0.7,1.0);\n    if(rd.z < 0.1)\n    {\n        float y = 0.00;\n        for(float x = 0.39; x < 6.28; x += 0.39)\n        {\n            vec3 height = texture(iChannel0, vec2(x)).xyz;\n            y+= 0.03*height.x;\n\t\t\tbubble = speck(vec2(sin(iGlobalTime+x)*0.5+0.2,cos(iGlobalTime*height.z*2.1+height.x*1.7)*0.2+0.2),\n            rd.xy,(cos(iGlobalTime+height.y*2.3+rd.z*-1.0)*-0.01+0.25));\n            colorBubble += bubble*vec3(-0.1*rd.z,-0.5*rd.z,1.0);\n        }\n    }    \n         \n    float t = res.z;\n    \n    if (t < tmax) \n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor;\n        \n        // add bumps\n        nor = getTerrainNormal(pos);\n        nor = normalize(nor + 0.05 * getTerrainNormal(pos * 8.0));\n \n        float sun = clamp(dot(sunDirection, nor), 0.0, 1.0);\n        sky = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        vec3 diffuse=mix(texture(iChannel2, vec2(pos.x*pow(pos.y,0.01),pos.z*pow(pos.y,0.01))).xyz,vec3(1.0,1.0,1.0),clamp(1.1-pos.y,0.0,1.0));\n\n        diffuse *= caustic(vec2(mix(pos.x,pos.y,0.2),mix(pos.z,pos.y,0.2))*1.1);\n        vec3 lightColor = 1.0 * sun * sunLightColor;\n\n        lightColor += 0.7 * sky * skyLightColor;\n\n        color *= 0.8 * diffuse*lightColor;\n\n        // fog\n        color = mix(color, horizonColor, 1.0 - exp(-0.3 *pow(t,1.0) ));\n    }\n    else \n    {\n        sky = clamp(0.8 * (1.0 - 0.8 * rd.y), 0.0, 1.0);\n        color = sky * skyColor;\n        color += ((0.3*caustic(vec2(p.x,p.y*1.0)))+(0.3*caustic(vec2(p.x,p.y*2.7))))*pow(p.y,4.0);\n\n        // horizon\n        color = mix(color, horizonColor, pow(1.0 - pow(rd.y,4.0), 20.0));       \n    }\n    \n    // special effects\n    color += colorBubble;\n    color += GodRays(p)*mix(float(skyColor),1.0,p.y*p.y)*vec3(0.7,1.0,1.0);\n    \n    // gamma correction\n    vec3 gamma = vec3(0.46);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}\n\nvoid main() {\n\tvec4 color;\n\tmainImage(color, glFragCoord.xy);\n\n\tcolor.w = 1.0;\n\tglFragColor = color;\n}\n\n\n","fragUniformControlList":[{"name":"iChannel1","typeString":"sampler2D","value":"Shadertoy/res/tex03.jpg"},{"name":"iChannel2","typeString":"sampler2D","value":"Shadertoy/res/tex03.jpg"},{"name":"iChannel0","typeString":"sampler2D","value":"Shadertoy/res/tex16.png"},{"name":"z_pos","typeString":"float","value":-1.182},{"name":"depthTex","typeString":"sampler2D","value":"[depthmap]"}]},"vertexCode":{"vert":"#version 330\n#define SYNTHCLIPSE_ONLY\nlayout(location = 0) in vec3 VertexPosition;\n\n// Matrix used for tiled rendering:\nuniform mat4 TileMatrix = mat4(1.0);\nuniform vec2 resolution;\n\n// custom version of gl_FragCoord, used for tiled rendering.\nout vec4 glFragCoord;\n\nvoid main() {\n\tvec2 v = VertexPosition.xy;\n\tv.x = v.x * TileMatrix[0][0] + TileMatrix[3][0];\n\tv.y = v.y * TileMatrix[1][1] + TileMatrix[3][1];\n\tv = v * 0.5 + 0.5;\n\tglFragCoord.xy = v * resolution;\n\n\tgl_Position = vec4(VertexPosition, 1.0);\n}\n\n\n"}},"name":"Beneath-the-Sea.stoy"}}}