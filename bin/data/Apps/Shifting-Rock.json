{"boxworldShader":{"mainProgram":{"code":{"fragmentCode":{"frag":"#version 330\nlayout(location = 0) out vec4 glFragColor;\nin vec4 glFragCoord; // custom version of gl_FragCoord, used for tiled rendering.\n#define SYNTHCLIPSE_ONLY\nuniform vec3      iResolution;           // viewport resolution (in pixels)\nuniform float     iGlobalTime;           // shader playback time (in seconds)\nuniform float     iChannelTime[4];       // channel playback time (in seconds)\nuniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\nuniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\nuniform vec4      iDate;                 // (year, month, day, time in seconds)\nuniform float     iSampleRate;           // sound sample rate (i.e., 44100)\nuniform sampler2D depthTex;\t\t\t //! depthmap[]\n\nconst float scope = 1.0;\nfloat dh = 0.;\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ )\n\t{\n        p=m2*p*f+.6;\n        f*=1.2;\n        res+=sin(p.x+sin(2. * p.y));\n\t}\n\treturn res/3.;\n}\n\nfloat fbmabs( vec2 p ) {\n\tp *= 0.5;\n\tfloat f=1.;\n\tfloat r = 0.0;\n    for(int i = 0;i<8;i++){\n\t\tr += abs(noise( 6*p*f ))/f;\n\t    f *=2.;\n        p-=vec2(.01,.01)*r;\n\t}\n\treturn r/5;\n}\n\nfloat sea( vec2 p )\n{\n\tfloat f = 1.;\n\tfloat r = 0.0;\n    for(int i = 0; i<8; i++){\n\t\tr += (1.-abs(noise( 2*p*f -.12*iGlobalTime)))/f;\n\t    f *=2.;\n        p-=vec2(-.01,.04)*r;\n\t}\n\treturn r/40. + .5;\n}\n\nfloat rocks0(vec2 p){\n\tfloat d = texture(depthTex, p).r;\n    return d + .1 * fbmabs(p);\n}\n\nfloat rocks(vec2 p){\n\tfloat d = texture(depthTex, p).r;\n    return d + 9 * fbmabs(p);\n}\n\nfloat map( vec3 p)\n{\n\t//float d1 =p.y-.1*p.z+.2-.4*fbmabs(scope*p.xz);\n\tfloat d1 = p.y -.4*rocks0(p.xz);\n\tfloat d2 = p.y -.4*sea(scope*p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\n\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks0(p + e.xy) - rocks0(p - e.xy),\n        .05,//.008,\n\t\trocks0(p + e.yx) - rocks0(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\n\treturn sin(vec3(1.7,1.5,1)+1. + .45*fbmabs(p*4. - .02*iGlobalTime));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 30.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\n/*\n * main entry.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec2 p = fragCoord.xy / iResolution.y;\n\tp.x /= iResolution.x/iResolution.y;\n\tvec3 col = vec3(0.);\n\n    vec3 li = normalize(vec3(-2., 2., -2.));\n\n    /*\n     * world coordinates calc.\n     * according to 'http://9bitscience.blogspot.jp/2013/07/raymarching-distance-fields_14.html';\n     * this is looking straight down from 'up'.\n     */\n\tvec3 right = vec3(1, 0, 0);\n\tvec3 front = vec3(0, 0, 1);\n\tvec3 ro = right * p.x + front * p.y;\n\tro.y += 1.0;\n\tvec3 rd = normalize(cross(right, front));\n\n\t/*\n\t * raymarching.\n\t */\n    float t = march(ro, rd);\n\n    if(t > -0.001)\n    {\n        if(dh<0.)t-=dh;\n        vec3 pos = ro + t * rd;\n\n        float k=rocks(scope*pos.xz);\n\n        vec3 nor = normalRocks(scope*pos.xz);\n        float r = max(dot(nor, li), 0.05)/2.;\n        if(dh < 0. && dh > -.08) r+=.5*exp(20. * dh);\n\n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<0.01){\n        \tvec3 nor = normalSea(scope*pos.xz);\n        \tnor = reflect(rd, nor);\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \tcol1 +=.2* sky(nor.yz);\n        }\n\t    col = .1+col1;\n\n\t}\n\n   \tfragColor = vec4(col, 1.0);\n}\n\n\nvoid main() {\n\tvec4 color;\n\tmainImage(color, glFragCoord.xy);\n\n\tcolor.w = 1.0;\n\tglFragColor = color;\n}\n\n\n","fragUniformControlList":[{"name":"depthTex","typeString":"sampler2D","value":"[depthmap]"}]},"vertexCode":{"vert":"#version 330\n#define SYNTHCLIPSE_ONLY\nlayout(location = 0) in vec3 VertexPosition;\n\n// Matrix used for tiled rendering:\nuniform mat4 TileMatrix = mat4(1.0);\nuniform vec2 resolution;\n\n// custom version of gl_FragCoord, used for tiled rendering.\nout vec4 glFragCoord;\n\nvoid main() {\n\tvec2 v = VertexPosition.xy;\n\tv.x = v.x * TileMatrix[0][0] + TileMatrix[3][0];\n\tv.y = v.y * TileMatrix[1][1] + TileMatrix[3][1];\n\tv = v * 0.5 + 0.5;\n\tglFragCoord.xy = v * resolution;\n\n\tgl_Position = vec4(VertexPosition, 1.0);\n}\n\n\n"}},"name":"Shifting-Rock.stoy"}}}
