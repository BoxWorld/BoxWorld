{"boxworldShader":{"mainProgram":{"code":{"fragmentCode":{"frag":"#version 330\nlayout(location = 0) out vec4 glFragColor;\nin vec4 glFragCoord; // custom version of gl_FragCoord, used for tiled rendering.\n#define SYNTHCLIPSE_ONLY\n/*!\n * <info>\n * <author>hanmaokun [ https://www.shadertoy.com/user/hanmaokun ]<\/author>\n * <name>Shifting Rock<\/name>\n * \n * <description>\n *   A steal and composition of guil's \"Rocky Coast\" and Malhar's \"Shifting Islands\",\n *   with a view angle of looking straight down from up. I had to say I am no expert\n *   on CG, and don't really understand the alg inside, but this awesome community\n *   makes it easy <img src=\"/img/emoticonHappy.png\"/>\n * <\/description>\n * \n * <url>https://www.shadertoy.com/view/ldt3zj<\/url>\n * \n * <date>2015-12-25<\/date>\n * \n * <tags>procedural, 3d, sea, rock<\/tags>\n * \n * <synthclipse-importer-legal-note>\n *   As noted in: [ https://www.shadertoy.com/terms ]:\n *   If the author did not stated otherwise, this shader is licensed under\n *   Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License \n *   [ http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US ].\n * <\/synthclipse-importer-legal-note>\n * <\/info>\n */\n\nuniform vec3      iResolution;           // viewport resolution (in pixels)\nuniform float     iGlobalTime;           // shader playback time (in seconds)\nuniform sampler2D depthTex;\t\t\t//! depthmap[]\n\nfloat dh = 0.;\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\nfloat noise(in vec2 p){\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ )\n\t{\n        p=m2*p*f+.6;\n        f*=1.2;\n        res+=sin(p.x+sin(2. * p.y));\n\t}\n\treturn res/3.;\n}\n\nfloat fbmabs( vec2 p ) {\n\tp *= 0.5;\n\tfloat f=1.;\n\tfloat r = 0.0;\n    for(int i = 0;i<8;i++){\n\t\tr += abs(noise( p*f ))/f;\n\t    f *=2.;\n        p-=vec2(.01,.01)*r;\n\t}\n\treturn r;\n}\n\nfloat sea( vec2 p )\n{\n\tfloat f = 1.;\n\tfloat r = 0.0;\n    for(int i = 0; i<8; i++){\n\t\tr += (1. - abs(noise( p*f -.12*iGlobalTime)))/f;\n\t    f *=2.;\n        p -= vec2(-.01, .04) * r;\n\t}\n\treturn r/4.+.5;\n}\n\nfloat rocks(vec2 p){\n\treturn texture(depthTex, p).r + + 0.3*fbmabs(6 * p);\n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 = p.y - 0.8 * rocks(p.xz);\n\tfloat d2 = p.y - sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\n\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .05,//.008,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 3.0;\n\tconst float precis = 0.01;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 3; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\n/*\n * main entry.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p =  fragCoord.xy / iResolution.y;\n\tp.x /= iResolution.x/iResolution.y;\n\tvec3 col = vec3(0.);\n\n    vec3 li = normalize(vec3(-2., 2., -2.));\n\n\tvec3 right = vec3(1, 0, 0);\n\tvec3 front = vec3(0, 0, 1);\n\tvec3 ro = right * p.x + front * p.y;\n\tro.y += 1.0;\n\tvec3 rd = normalize(cross(right, front));\n\n\t/*\n\t * raymarching.\n\t */\n    float t = march(ro, rd);\n\n    if(t > -0.001)\n    {\n        if(dh < 0.) t -= dh;\n        vec3 pos = ro + t * rd;\n\n        float k=rocks(pos.xz);\n\n        vec3 nor = normalRocks(pos.xz);\n        float r = max(dot(nor, li), 0.05)/2.;\n        if(dh < 0. && dh > -.08) r+=.5*exp(20. * dh);\n\n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh < 0.08){\n        \tvec3 nor = normalSea(pos.xz);\n        \tnor = reflect(rd, nor);\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        }\n\t    col = .1 + col1;\n\n\t}\n\n   \tfragColor = vec4(col, 1.0);\n}\n\n\nvoid main() {\n\tvec4 color;\n\tmainImage(color, glFragCoord.xy);\n\n\tcolor.w = 1.0;\n\tglFragColor = color;\n}\n\n\n","fragUniformControlList":[{"name":"depthTex","typeString":"sampler2D","value":"[depthmap]"}]},"vertexCode":{"vert":"#version 330\n#define SYNTHCLIPSE_ONLY\nlayout(location = 0) in vec3 VertexPosition;\n\n// Matrix used for tiled rendering:\nuniform mat4 TileMatrix = mat4(1.0);\nuniform vec2 resolution;\n\n// custom version of gl_FragCoord, used for tiled rendering.\nout vec4 glFragCoord;\n\nvoid main() {\n\tvec2 v = VertexPosition.xy;\n\tv.x = v.x * TileMatrix[0][0] + TileMatrix[3][0];\n\tv.y = v.y * TileMatrix[1][1] + TileMatrix[3][1];\n\tv = v * 0.5 + 0.5;\n\tglFragCoord.xy = v * resolution;\n\n\tgl_Position = vec4(VertexPosition, 1.0);\n}\n\n\n"}},"name":"Shifting-Rock.stoy"}}}
