{"boxworldShader":{"mainProgram":{"code":{"fragmentCode":{"frag":"#version 330\nlayout(location = 0) out vec4 glFragColor;\nin vec4 glFragCoord; // custom version of gl_FragCoord, used for tiled rendering.\n#define SYNTHCLIPSE_ONLY\nuniform vec3 iResolution;           // viewport resolution (in pixels)\nuniform float iGlobalTime;          // shader playback time (in seconds)\nuniform float iChannelTime[4];      // channel playback time (in seconds)\nuniform vec3 iChannelResolution[4]; // channel resolution (in pixels)\nuniform vec4 iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\nuniform vec4 iDate;                 // (year, month, day, time in seconds)\nuniform sampler2D iChannel0; //! texture[\"Shadertoy/res/tex16.png\"]\n\nuniform float z_pos;\t\t\t\t//! slider[-2, 0.182, 2];\nuniform float h_ratio;\t\t\t\t//! slider[0, 0.1, 1];\nuniform float light_ratio;\t\t\t//! slider[-6, 0.6, 6];\n\nuniform sampler2D depthTex;\t\t\t//! depthmap[]\n\n//#define SHADOWS\n#define HEIGHT_RATIO 0.1\n\n#define SHADOW_ITERS 10\n#define SHADOW_QUALITY 3.0\n#define REFLECTION_ITERS 50\n#define REFLECTION_QUALITY 5.0\n\n#define LINEAR_ITERS 80\n#define BINARY_ITERS 11\n#define LINEAR_ACCURACY 0.8\n#define LINEAR_DISTANCE_RATIO 0.2\n#define FOG_BASE 0.06\n\nvec3 cameraOrigin, rayDir;\n\n/* ################### */\n#define time iGlobalTime*0.05\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\n\tif(x0>=y0)\n\t{\n\t\tif\t\t(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if\t(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse \t\t\t{ i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Z order\n\t}\n\telse\n\t{\n\t\tif\t\t(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if\t(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse \t\t\t{ i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\n\tfloat x1 = x0 - float(i1) + g3;\n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3;\n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3;\n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\n\n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\n\n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\n}\n\nfloat inverseRidgedMultifractal(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*abs(simplex3D( p )); p = p*2.01;\n    f += 0.25000*abs(simplex3D( p )); p = p*2.02;\n    f += 0.12500*abs(simplex3D( p )); p = p*2.03;\n    f += 0.06250*abs(simplex3D( p )); p = p*2.04;\n    f += 0.03125*abs(simplex3D( p ));\n\treturn 1.0-f;\n}\n\n/* ################### */\nfloat scene(vec3 pos) {\n\tvec2 p = pos.xz / iResolution.xy;\n\tfloat d = texture(depthTex, p.xy).r;\n\td *= 100;\n\treturn pos.y - d;\n}\n\nfloat sceneHigh(vec3 pos) {\n\tvec2 p = pos.xz / iResolution.xy;\n\tfloat d = texture(depthTex, p.xy).r;\n\td *= 100;\n\treturn pos.y - d;\n}\n\nvec3 normal(vec3 x) {\n\tconst vec2 eps = vec2(0.1, 0.0);\n\tfloat h = scene(x);\n\treturn normalize(vec3(\n\t\t(scene(x+eps.xyy)-h),\n\t\t(scene(x+eps.yxy)-h),\n\t\t(scene(x+eps.yyx)-h)\n\t));\n}\n\nvec3 normalHigh(vec3 x) {\n\tconst vec2 eps = vec2(0.05, 0.0);\n\tfloat h = sceneHigh(x);\n\treturn normalize(vec3(\n\t\t(sceneHigh(x+eps.xyy)-h),\n\t\t(sceneHigh(x+eps.yxy)-h),\n\t\t(sceneHigh(x+eps.yyx)-h)\n\t));\n}\n\nfloat shadow(vec3 rpos, vec3 rdir) {\n\tfloat t = 1.0;\n\tfloat sh = 1.0;\n\n\tfor (int i = 0; i < SHADOW_ITERS; i++) {\n\t\tvec3 pos = rpos + rdir * t;\n\t\tfloat h = scene(pos);\n\t\tif (h < 0.01) return 0.0;\n\t\tsh = min(sh, h/t*8.0);\n\t\tt += max(h, SHADOW_QUALITY);\n\t}\n\n\treturn sh;\n}\nconst float waterHeight = 80.0;\nconst vec3 lightDir = vec3(0.819232, 0.573462, 0.);\n\nvec3 calculateFogColor(vec3 rpos, vec3 rdir) {\n\tvec3 col = mix(vec3(0.3, 0.5, 0.7), vec3(0.0, 0.05, 0.1), clamp(rdir.y*2.5, 0.0, 1.0));\n\tcol += pow(dot(lightDir, rdir) * 0.5 + 0.5, 2.0) * vec3(0.3, 0.2, 0.1);\n\treturn col;\n}\n\nvec3 shade(vec3 rpos, vec3 rdir, float t, vec3 pos) {\n\tfloat watert = ((rpos.y - waterHeight-820.0) / rdir.y);\n\n\t// Calculate fog\n\tfloat b = 0.01;\n\tfloat fogt = min(watert, t);\n\tfloat fog = 1.0 - FOG_BASE * exp(-rpos.y*b) * (1.0-exp(-fogt*rdir.y*b)) / rdir.y;\n\tvec3 fogColor = calculateFogColor(rpos, rdir);\n\n\tvec4 ns = texture(iChannel0, pos.xz * 0.0001);\n\n\tif (fog < 0.01) return fogColor;\n\n\tvec3 nl = normal(pos);\n\tvec3 n = normalHigh(pos);\n\tfloat h = pos.y;\n\n\tfloat slope = n.y;\n\tvec3 albedo = vec3(0.36, 0.25, 0.15);\n\n\t// Apply texture_ above water\n\tif (watert > t) {\n\t\tfloat snowThresh = 1.0 - smoothstep(-50.0, -40.0, h) * 0.4 + 0.1;\n\t\tfloat grassThresh = smoothstep(-70.0, -50.0, h) * 0.3 + 0.75;\n\n\t\tif (nl.y < 0.65)\n\t\t\talbedo = mix(albedo, vec3(0.65, 0.6, 0.5), smoothstep(0.65,0.55,nl.y));\n\t\tif (slope > grassThresh - 0.05)\n\t\t\talbedo = mix(albedo, vec3(0.4, 0.6, 0.2), smoothstep(grassThresh-0.05,grassThresh+0.05,slope));\n\t\tif (slope > snowThresh - 0.05)\n\t\t\talbedo = mix(albedo, vec3(1.0, 1.0, 1.0), smoothstep(snowThresh-0.05,snowThresh+0.05,slope));\n\t}\n\n\t// Fade in 'beach' and add a bit of noise\n\talbedo = mix(albedo, vec3(0.6, 0.5, 0.2), smoothstep(-waterHeight+4.0,-waterHeight+0.5,h));\n\n\t// Lighting\n\tfloat diffuse = clamp(dot(n, lightDir), 0.0, 1.0);\n\t#ifdef SHADOWS\n\tif (diffuse > 0.005) diffuse *= shadow(pos, vec3(lightDir.xy, -lightDir.z));\n\t#endif\n\tvec3 col = vec3(0.0);\n\tcol += albedo * vec3(1.0, 0.9, 0.8) * diffuse;\n\tcol += albedo * fogColor * max(n.y * 0.5 + 0.5, 0.0) * 0.5;\n\n\t// Shade water\n    vec3 light = vec3(0.0,0.0,0.0);\n    vec2 water_wind_direction = vec2(-time*0.5, time*0.2);\n\n\tif (t >= watert) {\n\t\tfloat dist = t - watert;\n\t\tvec3 wpos = rpos+rdir*watert;\n\t\tcol *= exp(-vec3(0.3, 0.15, 0.08)*dist);\n\n\t\tfloat f = 1.0 - pow(1.0 - clamp(-rdir.y, 0.0, 1.0), 5.0);\n\t\tvec3 refldir = rdir * vec2(-1.0, 1.0).yxy;\n\t\trefldir = normalize(refldir + ns.xyz * 0.1);\n\t\tvec3 refl = calculateFogColor(wpos, refldir);\n\t\tcol = mix(refl, col, f);\n\n\t\tvec2 uv = pos.xz / iResolution.xy;\n\t\tfloat b = inverseRidgedMultifractal(vec3((time+50.0)*0.5, water_wind_direction + uv - vec2(-.005, .005)));\n\t\tfloat v = inverseRidgedMultifractal(vec3((time+50.0)*0.5, water_wind_direction + uv));\n\t\tfloat toadd = (b-v) * light_ratio;\n\t\tlight = vec3(toadd);\n\n\t\tcol += light;\n\t}\n\n\treturn mix(fogColor, col, fog);\n}\n/* ################### */\n\nfloat terrain_map(vec3 p) {\n\tvec2 p0 = p.xz;\n\treturn p.y - 100 * texture(depthTex, p0/iResolution.xy).r;\n}\n\nfloat map( vec3 p)\n{\n\tfloat d_terrain = terrain_map(p);\n\treturn d_terrain;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 900.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 8; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = fragCoord.xy;\n\n\tcameraOrigin = vec3(0.5 * iResolution.x, 0.91 * iResolution.y, z_pos * iResolution.y);\n\tvec3 cameraTarget = vec3(uv.x, 0.0, uv.y);\n\tvec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n\trayDir = cameraDir;\n\n    float t = march(cameraOrigin, rayDir);\n    vec3 col = vec3(0);\n\n\tif(t > -0.001)\n\t{\n        vec3 pos = cameraOrigin + t * rayDir;\n        pos.y -= 120;\n        col = shade(cameraOrigin, rayDir, t, pos);\n\t}\n\n\tfragColor = vec4(pow(col, vec3(0.4545)), 1.0);\n}\n\nvoid main() {\n\tvec4 color;\n\tmainImage(color, glFragCoord.xy);\n\n\tcolor.w = 1.0;\n\tglFragColor = color;\n}\n\n\n","fragUniformControlList":[{"name":"iChannel0","typeString":"sampler2D","value":"Shadertoy/res/tex16.png"},{"name":"z_pos","typeString":"float","value":0.182},{"name":"h_ratio","typeString":"float","value":0.1},{"name":"light_ratio","typeString":"float","value":0.6},{"name":"depthTex","typeString":"sampler2D","value":"[depthmap]"}]},"vertexCode":{"vert":"#version 330\n#define SYNTHCLIPSE_ONLY\nlayout(location = 0) in vec3 VertexPosition;\n\n// Matrix used for tiled rendering:\nuniform mat4 TileMatrix = mat4(1.0);\nuniform vec2 resolution;\n\n// custom version of gl_FragCoord, used for tiled rendering.\nout vec4 glFragCoord;\n\nvoid main() {\n\tvec2 v = VertexPosition.xy;\n\tv.x = v.x * TileMatrix[0][0] + TileMatrix[3][0];\n\tv.y = v.y * TileMatrix[1][1] + TileMatrix[3][1];\n\tv = v * 0.5 + 0.5;\n\tglFragCoord.xy = v * resolution;\n\n\tgl_Position = vec4(VertexPosition, 1.0);\n}\n\n\n"}},"name":"Lakes-and-mountains_ofs130.stoy"}}}